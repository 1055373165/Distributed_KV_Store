# 常用缓存策略

缓存淘汰策略常见的有：fifo、lfu（least frequenty used） 和 lru；

## fifo

### 算法思想

fifo 淘汰策略认为最早添加的记录，其不再被使用的可能性比刚添加的记录要打，因此在缓存达到缓存限制时，优先淘汰这些最早添加的记录。

### 实现

使用双向链表模拟队列，将新添加的元素放到队尾（即链表的头部），当缓存容量满的时候，从队头（也就是链表尾部）删除元素。

但是这种淘汰策略仅使用于一些固定的场景，在大部分场景下并不适用；因为它无法根据数据的使用频次、时间等维度进行优化，既没有实现基本局部性、也没有实现高级局部性，因此在很多时候缓存命中率并不高。

## lfu（least frequently used）

### 算法思想

lfu 算法认为最少被访问的缓存条目在将来被访问的概率最小，因此在缓存容量满的时候，优先淘汰那些访问频率最少的缓存条目。它实现了高级局部性。

### 实现

LFU 的算法实现需要维护一个有序队列，每次访问缓存条目时更新对应条目的访问计数，并根据访问计数将有序队列进行重排，在需要淘汰记录时优先选择那些访问次数少的记录，即队列尾部的那些记录，LFU 的算法命中率比较高，但是也存在一些缺点。

### 缺点

LFU 基于访问频率对缓存条目排序，那么它就会收到历史数据的影响；比如一条数据曾经高频访问，后来突然间这个数据被替换为一个新的数据，几乎再也用不到了，但是由于它之前积累的访问次数，它仍然位于有序队列的前部，迟迟得不到释放，一旦这样的数据累积，就会导致缓存命中率的下降。

### 分析

fifo 实现简单，但是没有实现基本局部性也没有实现高级局部性，无法根据访问频率、最近是否使用等维度进行优化，所以命中率并不高。

而 Lfu 相比于 fifo 更近一步，从访问频率维度进行算法优化，通过对访问次数的统计并基于访问次数对缓存条目排序往往能达到不错的命中率。其缺点是每次插入或者访问缓存条目时都需要更新访问计数并根据访问计数对缓存记录进行重排，即高命中率是通过更多的工作量换取的。另外，它容易受历史数据的影响，导致那些曾经经常使用，但是现在基本不再使用的缓存条目无法及时从缓存中移除，占用缓存空间，在数量较多时影响缓存的命中率。

## LRU （least recently used）

后来人们又设计了一种折中的淘汰算法，就是 LRU，最近最少使用淘汰算法。

### 算法思想

LRU 认为，如果数据最近被访问，那么将下来很有可能再次被访问，因此在需要淘汰数据时，优先淘汰那些最近不常使用的缓存条目。

相比于仅考虑加入时间的 fifo 算法和从访问频率维度出发进行优化的 lfu 算法，lru 算法是一种相对比较平衡的算法，它实现了基本局部性。

### 算法实现

维护一个队列（使用双向链表模拟）来存储键值记录，使用另一种数据结构 map 维护键到双向链表缓存记录的映射，当需要访问某个键的值时，根据 map 找到键在双向链表中的位置，取出键对应的值；在需要删除缓存条目时，直接从双向链表的末尾进行移除即可；这种设计对缓存条目的访问、新增、删除都在 o(1) 可以完成，非常高效。

### 缺点

但 lru 也有它的问题，我们知道 lru 缓存容量是有上限的，一旦插入新的缓存条目超过了这个限制，就需要从队头移除缓存条目，直至符合这个限制。

# 局部性分析

设想一种极端情况：我们插入了一个内存占用非常大的记录，导致缓存占用超出限制非常多，按照 lru 算法逻辑，我们需要从队头不断地移除缓存使其满足缓存容量限制。我们将移除大量的缓存，而且这些缓存可能是最近刚刚被访问过缓存记录，这就导致了缓存几乎失效。所以 lru 并没有实现高级局部性，仅支持基本局部性。因此即使是那些高频访问的记录也有可能因为插入一个大的数据被替代掉。

这只是其中一个原因，最重要的原因是因为 lru 是根据最近使用情况对缓存记录排序，高访问量并不能给缓存条目带来额外的优先级。假设一个 lru 缓存容量为 2，然后用户进行了 100 次访问，其中 98 次先访问条目 1，然后现在缓存中有条目 1 的缓存位于队头，接着用户插入条目 2，该条目直接插入到队头，现在访问次数为 98 次的条目 1 被赶到了队尾，离淘汰只差一步之遥，假设此时用户又插入了一条条目 3，那么条目 3 插入到队头，条目2 和条目 1 往队尾移动，此时缓存容量超过了 2，触发淘汰策略，条目 3 被删除，即使它的访问次数是另外两个条目的 98 倍。所以我们说 lru 没有实现高级局部性。

基本局部性原则认为：如果一个进程访问了内存中的某个位置，那么它可能很多会再次访问该位置及其附近的区域。（这涉及到操作系统高速缓存从内存读取数据的策略，即不是仅读取需要的那部分数据，而是按照内存块读取，这样可能将访问的这块内存附近的数据也读取出来，那么下次访问时就无需从内存中加载了，这就是满足基本局部性），因此基本局部性考虑的是范围！

高级局部性则认为：如果访问某个位置的次数越多，那么重新访问的概率就越大。而高级局部性考虑的是访问频次，它保证那些访问次数多的数据是保留在高速缓存中的，无需再去内存中读取。可见这和 lfu 的淘汰策略是对应的。